---
layout: post
title: "Ауентификация с JSON Web Tokens"
date: "2015-01-27 20:50:32 +0300"
comments: true
categories:
---
Ауентификация c JWT не нуждается в сессиях, не имеет проблем с мобильными устройствами, не нуждается в CSRF и прекрасно работает с CORS. Но как это всё работает?


<!--more-->

Представьте себе самое стандартное веб-приложение, вы ходите по страницам и решаете зарегистрироваться. Потом вы начинаете заполнять ваши данные в необходимой форме. И в ответ вы получите JSON токен. Что же можно делать с этим токеном. Например, вы можете получить функционал зарегистрированного пользователя (личные сообщения, страница профиля и т.п).  

### Как работает JWT

Теперь вы имеете примерное представление о том, как работает JWT. Рассмотрим этот процесс с технической точки зрения.

JWToken самодостаточен и поэтому и когда вы создаёте его он будет иметь все необходимые части внутри себя. Что это за части? Токен разделён на три части: хеддер, полезная нагрузка и подпись.

Хеддер обычно содержит две вещи: тип токена и название алгоритма. Например, {typ: 'JWT', alg: 'HS256'}. Это зашифровывается в base64.

Полезная нагрузка — это информация, которую вы хотите передать в токен, например, {user: 2} или даже {user: 2, admin: true}. Это зашифровывается в base64.

Для подписи мы берём закодированный хеддер, закодированую полезную нагрузку, секретый ключ, который мы предоставляем, алгоритм, указанный в хеддере и подписываем это.

В конце концов мы получаем токен в виде: xxxxxxxxxxx.yyyy.zzzzzzzzzzzz, где x — это закодированный хеддер, y — полезная нагрузка, а z — подпись.

Возвращаясь к примеру. Когда мы логинимся, мы получаем токен и с этим токеном мы можем делать любой запрос к серверу, просто передавая ему наш токен (обычно в хеддере). Как же происходит работа с токеном на сервере, если у нас нет сессий и мы не записываем токен в базу данных? Как мы идентифицируем пользователя?

Когда мы делаем запрос, то мы посылаем токен на сервер. Там мы его расшифровываем, обычно с помощью библиотеки, которая сделает расшифровку полезной нагрузки и хеддера, чтобы посмотреть тип и используемый алгоритм. Произойдет варификация данных с подписью и если всё впорядке будет возвращена полезная нагрузка. Так как в полезной нагрузке может быть user_id, то мы сможем сделать запрос к базе данных с этим пользователем.

Значит порядок таков: я логинюсь -> я получаю токен -> я делаю запрос со своим токеном -> токен расшифровывается -> с полученным user_id происходит запрос на данные, возвращаемые, например, в виде JSON.

Что будет, если попробывать подменить полезную нагрузка и передать на сервер ложный параметр? Это не сработает. Подпись токена, состоит из оригинального хеддера и полезной нагрузки.

Есть еще кое-что важное для продвинутых пользователей. Например, можно задать время истечения действительности токена. Это полезно, например, для того, чтобы заставить пользователя перелогиниться черех X дней.

В заключение, надо заметить, что с таким подходом лучше использовать SSL, так как токен будет передаваться каждый раз при запросе.

Original source: http://angular-tips.com/blog/2014/05/json-web-tokens-introduction/
